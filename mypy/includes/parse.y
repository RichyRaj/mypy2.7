// Generated by transforming |cwd:///work-in-progress/2.7.2-bisonified.y| on 2016-11-23 at 15:46:56 +0000
%{
	int yylex (void);
	extern char *yytext;
	void yyerror (const char *);

	#include <iostream>
	#include <vector>
	#include "includes/ast.h"

	// Singleton for memory management
	PoolOfNodes& pool = PoolOfNodes::getInstance();

	// =========================States related to indexing ========================
	// Structs for indexing
	struct RangedIndexOf {
		int start;
		int end;
		int step;
	};
	bool isIndexOn = false;
	bool hasColon = false;
	bool shouldUseStrLen = false;
	bool startIndexEmpty = false;
	RangedIndexOf index_range;
	// =========================States related to indexing ========================

	// =========================States related to indexing ========================
	bool isFunctionCallOn = false;
	// =========================States related to indexing ========================

%}

// Type the stack
%union {
	Node* node;
	std::vector<Node*>* fnStatements;
	std::vector<Node*>* args;
  int intVal;
	float floatVal;
	char* id;
	char* str;
}

// Type the grammar
%type<node> atom power factor term arith_expr shift_expr
%type<node> and_expr xor_expr expr comparison not_test and_test or_test test opt_test opt_yield_test opt_test_only
%type<node> testlist pick_yield_expr_testlist star_EQUAL expr_stmt
%type<node> pick_yield_expr_testlist_comp testlist_comp
%type<node> sliceop opt_sliceop
%type<intVal> PLUS MINUS pick_PLUS_MINUS
%type<intVal> STAR SLASH PERCENT DOUBLESLASH pick_multop
%type<intVal> PLUSEQUAL MINEQUAL STAREQUAL SLASHEQUAL PERCENTEQUAL AMPEREQUAL VBAREQUAL CIRCUMFLEXEQUAL LEFTSHIFTEQUAL RIGHTSHIFTEQUAL DOUBLESTAREQUAL DOUBLESLASHEQUAL augassign
%type<id> NAME
%type<node> stmt simple_stmt compound_stmt print_stmt return_stmt flow_stmt if_stmt small_stmt suite funcdef decorated
%type<fnStatements> plus_stmt
%type<intVal> comp_op LESS GREATER EQEQUAL GREATEREQUAL LESSEQUAL GRLT NOTEQUAL
%type<intVal> IN IS NOT
%type<node> fpdef
// Formal Params
%type<args> star_fpdef_COMMA varargslist parameters
// Actual Params
%type<args> star_argument_COMMA arglist opt_arglist trailer star_trailer
%type<node> argument pick_argument

%left PLUS MINUS
%left MULT DIV PERCENT DOUBLESLASH
%left DOUBLESTAR

// 83 tokens, in alphabetical order:
%token AMPEREQUAL AMPERSAND AND AS ASSERT AT BACKQUOTE BAR BREAK CIRCUMFLEX
%token CIRCUMFLEXEQUAL CLASS COLON COMMA CONTINUE DEDENT DEF DEL DOT DOUBLESLASH
%token DOUBLESLASHEQUAL DOUBLESTAR DOUBLESTAREQUAL ELIF ELSE ENDMARKER EQEQUAL
%token EQUAL EXCEPT EXEC FINALLY FOR FROM GLOBAL GREATER GREATEREQUAL GRLT
%token IF IMPORT IN INDENT IS LAMBDA LBRACE LEFTSHIFT LEFTSHIFTEQUAL LESS
%token LESSEQUAL LPAR LSQB MINEQUAL MINUS NAME NEWLINE NOT NOTEQUAL INT_NUMBER FLOAT_NUMBER
%token OR PASS PERCENT PERCENTEQUAL PLUS PLUSEQUAL PRINT RAISE RBRACE RETURN
%token RIGHTSHIFT RIGHTSHIFTEQUAL RPAR RSQB SEMI SLASH SLASHEQUAL STAR STAREQUAL
%token STRING TILDE TRY VBAREQUAL WHILE WITH YIELD

%start start

%locations

%%

start
	: file_input
	;
file_input // Used in: start
	: star_NEWLINE_stmt ENDMARKER
	;
pick_NEWLINE_stmt // Used in: star_NEWLINE_stmt
	: NEWLINE
	| stmt
	{
		if ($1 != nullptr) {
			try {
				($1)->eval();
			} catch (std::string msg) {
				std::cout << "Error: " << msg << std::endl;
			} catch (...) {
				std::cout << "Error: Uncaught Exception" << std::endl;
			}
		} else {
			std::cout << "Error: Uncaught Exception (Shhh. There is a nullptr somewhere ...)" << std::endl;
		}
	}
	;
star_NEWLINE_stmt // Used in: file_input, star_NEWLINE_stmt
	: star_NEWLINE_stmt pick_NEWLINE_stmt
	| %empty
	;
decorator // Used in: decorators
	: AT dotted_name LPAR opt_arglist RPAR NEWLINE
	| AT dotted_name NEWLINE
	;
opt_arglist // Used in: decorator, trailer
	: arglist
	| %empty
	{
		$$ = nullptr;
	}
	;
decorators // Used in: decorators, decorated
	: decorators decorator
	| decorator
	;
decorated // Used in: compound_stmt
	: decorators classdef
	{
		$$ = nullptr;
	}
	| decorators funcdef
	{
		$$ = $2;
	}
	;
funcdef // Used in: decorated, compound_stmt
	: DEF NAME parameters COLON suite
	{
		/* $3 is the list of formal parameters - can either
		be a vector or nullptr
		*/
		$$ = new FunctionNode($2, $5, $3);
		delete[] $2;
		pool.add($$);
	}
	;
parameters // Used in: funcdef
	: LPAR varargslist RPAR
	{
		// TODO: Delete it !
		$$ = $2;
		std::cout<<"Rocket has collected your params in a vector ! ..  "<<$$->size()<<std::endl;
	}
	| LPAR RPAR
	{
		$$ = nullptr;
	}
	;
varargslist // Used in: parameters, old_lambdef, lambdef
	: star_fpdef_COMMA pick_STAR_DOUBLESTAR
	| star_fpdef_COMMA fpdef opt_EQUAL_test opt_COMMA
	{
		// Only this is applicable for the project
		// parameters without a comma are matched here..
		// So the last or the only one param is here
		std::cout<<"I am GROOT.."<<std::endl;
		$$->push_back($2);
	}
	;
opt_EQUAL_test // Used in: varargslist, star_fpdef_COMMA
	: EQUAL test
	| %empty
	;
star_fpdef_COMMA // Used in: varargslist, star_fpdef_COMMA
	: star_fpdef_COMMA fpdef opt_EQUAL_test COMMA
	{
		$$ = $1;
		$$->push_back($2);
		std::cout<<"I am GROOT GROOT.."<<std::endl;
		// parameters with  comma are matched here..
	}
	| %empty
	{
		std::cout<<"I am EMPTY GROOT.."<<std::endl;
		// Seems to get matched always
		$$ = new std::vector<Node*>();
		$$->reserve(4);
	}
	;
opt_DOUBLESTAR_NAME // Used in: pick_STAR_DOUBLESTAR
	: COMMA DOUBLESTAR NAME
	| %empty
	;
pick_STAR_DOUBLESTAR // Used in: varargslist
	: STAR NAME opt_DOUBLESTAR_NAME
	| DOUBLESTAR NAME
	;
opt_COMMA // Used in: varargslist, opt_test, opt_test_2, testlist_safe, listmaker, testlist_comp, pick_for_test_test, pick_for_test, pick_argument
	: COMMA
	| %empty
	;
fpdef // Used in: varargslist, star_fpdef_COMMA, fplist, star_fpdef_notest
	: NAME
	{
		std::cout<<"Named formal parameter.... "<<yylval.id<<std::endl;
		// TODO: Check if deleting the vector in the func node will cause a double free
		$$ = new IdentNode(yylval.id);
		pool.add($$);
		// TODO: check if leaks
		delete[] yylval.id;
	}
	| LPAR fplist RPAR
	{
		$$ = nullptr;
	}
	;
fplist // Used in: fpdef
	: fpdef star_fpdef_notest COMMA
	| fpdef star_fpdef_notest
	;
star_fpdef_notest // Used in: fplist, star_fpdef_notest
	: star_fpdef_notest COMMA fpdef
	| %empty
	;
stmt // Used in: pick_NEWLINE_stmt, plus_stmt
	: simple_stmt
	{
		$$ = $1;
	}
	| compound_stmt
	{
		$$ = $1;
	}
	;
simple_stmt // Used in: stmt, suite
	: small_stmt star_SEMI_small_stmt SEMI NEWLINE
	| small_stmt star_SEMI_small_stmt NEWLINE
	;
star_SEMI_small_stmt // Used in: simple_stmt, star_SEMI_small_stmt
	: star_SEMI_small_stmt SEMI small_stmt
	| %empty
	;
small_stmt // Used in: simple_stmt, star_SEMI_small_stmt
	: expr_stmt
	| print_stmt
	| del_stmt
	{
		$$ = nullptr;
	}
	| pass_stmt
	{
		$$ = nullptr;
	}
	| flow_stmt
	| import_stmt
	{
		$$ = nullptr;
	}
	| global_stmt
	{
		$$ = nullptr;
	}
	| exec_stmt
	{
		$$ = nullptr;
	}
	| assert_stmt
	{
		$$ = nullptr;
	}
	;
expr_stmt // Used in: small_stmt
	: testlist augassign pick_yield_expr_testlist
	// testlist should be already defined
	// testlist should be an ID node
	// get its value and do the corr. oprnt and re-assign
	{
		if ($2 == PLUSEQUAL) {
			$$ = new PlusAsgBinaryNode($1, $3);
		}
		if ($2 == MINEQUAL) {
			$$ = new MinusAsgBinaryNode($1, $3);
		}
		if ($2 == STAREQUAL) {
			$$ = new MulAsgBinaryNode($1, $3);
		}
		if ($2 == SLASHEQUAL) {
			$$ = new DivideAsgBinaryNode($1, $3);
		}
		if ($2 == DOUBLESLASHEQUAL) {
			$$ = new FloorDivideAsgBinaryNode($1, $3);
		}
		if ($2 == PERCENTEQUAL) {
			$$ = new ModAsgBinaryNode($1, $3);
		}
		if ($2 == DOUBLESTAREQUAL) {
			$$ = new PowerAsgBinaryNode($1, $3);
		}
		pool.add($$);
	}
	| testlist star_EQUAL
	{
		if ($2) {
			std::cout<<"The final final Asg/.."<<std::endl;
			$$ = new AsgBinaryNode($1, $2);
			pool.add($$);
		} else {
			// print back the result ...
			// TODO: Commenting out this code as function calls are considered here
			/*$$ = new PrintNode($1);
			pool.add($$);*/
			/* try {
				($1)->eval()->print();
			} catch (std::string msg) {
				std::cout<<"ERROR: "<< msg << std::endl;
			} catch ( ... ) {
		    std::cout << "Uncaught exception" << std::endl;
		  } */
		}
	}
	;
pick_yield_expr_testlist // Used in: expr_stmt, star_EQUAL
	: yield_expr
	{
		$$ = nullptr;
	}
	| testlist
	;
star_EQUAL // Used in: expr_stmt, star_EQUAL
	: star_EQUAL EQUAL pick_yield_expr_testlist
	{
		if ($1 == 0) {
			std::cout<<"Thats coool...."<<std::endl;
			$$ = $3;
		}
		if ($1 != 0 && $3 != 0){
			// TODO : I guess this code need not be here.
			// TODO: Check and remove
			/* std::cout<<$1<<std::endl; */
			$$ = new AsgBinaryNode($1, $3);
			pool.add($$);
		}
	}
	| %empty
	{
		$$ = nullptr;
	}
	;
augassign // Used in: expr_stmt
	: PLUSEQUAL
	{
		$$ = PLUSEQUAL;
	}
	| MINEQUAL
	{
		$$ = MINEQUAL;
	}
	| STAREQUAL
	{
		$$ = STAREQUAL;
	}
	| SLASHEQUAL
	{
		$$ = SLASHEQUAL;
	}
	| PERCENTEQUAL
	{
		$$ = PERCENTEQUAL;
	}
	| AMPEREQUAL
	{
		$$ = AMPEREQUAL;
	}
	| VBAREQUAL
	{
		$$ = VBAREQUAL;
	}
	| CIRCUMFLEXEQUAL
	{
		$$ = CIRCUMFLEXEQUAL;
	}
	| LEFTSHIFTEQUAL
	{
		$$ = LEFTSHIFTEQUAL;
	}
	| RIGHTSHIFTEQUAL
	{
		$$ = RIGHTSHIFTEQUAL;
	}
	| DOUBLESTAREQUAL
	{
		$$ = DOUBLESTAREQUAL;
	}
	| DOUBLESLASHEQUAL
	{
		$$ = DOUBLESLASHEQUAL;
	}
	;
print_stmt // Used in: small_stmt
	: PRINT opt_test
	{
		$$ = new PrintNode($2);
		pool.add($$);
		/* try {
			($2)->eval()->print();
		} catch (std::string msg) {
			std::cout<<"ERROR: "<< msg << std::endl;
		} catch ( ... ) {
    std::cout << "Uncaught exception " << std::endl;
  	} */
	}
	| PRINT RIGHTSHIFT test opt_test_2
	{
		$$ = nullptr;
	}
	;
star_COMMA_test // Used in: star_COMMA_test, opt_test, listmaker, testlist_comp, testlist, pick_for_test
	: star_COMMA_test COMMA test
	| %empty
	;
opt_test // Used in: print_stmt
	: test star_COMMA_test opt_COMMA
	| %empty
	{
		$$ = nullptr;
	}
	;
plus_COMMA_test // Used in: plus_COMMA_test, opt_test_2
	: plus_COMMA_test COMMA test
	| COMMA test
	;
opt_test_2 // Used in: print_stmt
	: plus_COMMA_test opt_COMMA
	| %empty
	;
del_stmt // Used in: small_stmt
	: DEL exprlist
	;
pass_stmt // Used in: small_stmt
	: PASS
	;
flow_stmt // Used in: small_stmt
	: break_stmt
	{
		$$ = nullptr;
	}
	| continue_stmt
	{
		$$ = nullptr;
	}
	| return_stmt
	{
		$$ = $1;
	}
	| raise_stmt
	{
		$$ = nullptr;
	}
	| yield_stmt
	{
		$$ = nullptr;
	}
	;
break_stmt // Used in: flow_stmt
	: BREAK
	;
continue_stmt // Used in: flow_stmt
	: CONTINUE
	;
return_stmt // Used in: flow_stmt
	: RETURN testlist
	{
		$$ = new ReturnNode($2);
		pool.add($$);
	}
	| RETURN
	{
		$$ = new ReturnNode(nullptr);
		pool.add($$);
	}
	;
yield_stmt // Used in: flow_stmt
	: yield_expr
	;
raise_stmt // Used in: flow_stmt
	: RAISE test opt_test_3
	| RAISE
	;
opt_COMMA_test // Used in: opt_test_3, exec_stmt
	: COMMA test
	| %empty
	;
opt_test_3 // Used in: raise_stmt
	: COMMA test opt_COMMA_test
	| %empty
	;
import_stmt // Used in: small_stmt
	: import_name
	| import_from
	;
import_name // Used in: import_stmt
	: IMPORT dotted_as_names
	;
import_from // Used in: import_stmt
	: FROM pick_dotted_name IMPORT pick_STAR_import
	;
pick_dotted_name // Used in: import_from
	: star_DOT dotted_name
	| star_DOT DOT
	;
pick_STAR_import // Used in: import_from
	: STAR
	| LPAR import_as_names RPAR
	| import_as_names
	;
import_as_name // Used in: import_as_names, star_COMMA_import_as_name
	: NAME AS NAME
	| NAME
	;
dotted_as_name // Used in: dotted_as_names
	: dotted_name AS NAME
	| dotted_name
	;
import_as_names // Used in: pick_STAR_import
	: import_as_name star_COMMA_import_as_name COMMA
	| import_as_name star_COMMA_import_as_name
	;
star_COMMA_import_as_name // Used in: import_as_names, star_COMMA_import_as_name
	: star_COMMA_import_as_name COMMA import_as_name
	| %empty
	;
dotted_as_names // Used in: import_name, dotted_as_names
	: dotted_as_name
	| dotted_as_names COMMA dotted_as_name
	;
dotted_name // Used in: decorator, pick_dotted_name, dotted_as_name, dotted_name
	: NAME
	| dotted_name DOT NAME
	;
global_stmt // Used in: small_stmt
	: GLOBAL NAME star_COMMA_NAME
	;
star_COMMA_NAME // Used in: global_stmt, star_COMMA_NAME
	: star_COMMA_NAME COMMA NAME
	| %empty
	;
exec_stmt // Used in: small_stmt
	: EXEC expr IN test opt_COMMA_test
	| EXEC expr
	;
assert_stmt // Used in: small_stmt
	: ASSERT test COMMA test
	| ASSERT test
	;
compound_stmt // Used in: stmt
	: if_stmt
	{
		$$ = $1;
	}
	| while_stmt
	{
		$$ = nullptr;
	}
	| for_stmt
	{
		$$ = nullptr;
	}
	| try_stmt
	{
		$$ = nullptr;
	}
	| with_stmt
	{
		$$ = nullptr;
	}
	| funcdef
	{
		$$ = $1;
	}
	| classdef
	{
		$$ = nullptr;
	}
	| decorated
	{
		$$ = nullptr;
	}
	;
if_stmt // Used in: compound_stmt
	: IF test COLON suite star_ELIF ELSE COLON suite
	{
		$$ = new IfNode($2, $4, $8);
		pool.add($$);
	}
	| IF test COLON suite star_ELIF
	{
		$$ = new IfNode($2, $4, nullptr);
		pool.add($$);
	}
	;
star_ELIF // Used in: if_stmt, star_ELIF
	: star_ELIF ELIF test COLON suite
	| %empty
	;
while_stmt // Used in: compound_stmt
	: WHILE test COLON suite ELSE COLON suite
	| WHILE test COLON suite
	;
for_stmt // Used in: compound_stmt
	: FOR exprlist IN testlist COLON suite ELSE COLON suite
	| FOR exprlist IN testlist COLON suite
	;
try_stmt // Used in: compound_stmt
	: TRY COLON suite plus_except opt_ELSE opt_FINALLY
	| TRY COLON suite FINALLY COLON suite
	;
plus_except // Used in: try_stmt, plus_except
	: plus_except except_clause COLON suite
	| except_clause COLON suite
	;
opt_ELSE // Used in: try_stmt
	: ELSE COLON suite
	| %empty
	;
opt_FINALLY // Used in: try_stmt
	: FINALLY COLON suite
	| %empty
	;
with_stmt // Used in: compound_stmt
	: WITH with_item star_COMMA_with_item COLON suite
	;
star_COMMA_with_item // Used in: with_stmt, star_COMMA_with_item
	: star_COMMA_with_item COMMA with_item
	| %empty
	;
with_item // Used in: with_stmt, star_COMMA_with_item
	: test AS expr
	| test
	;
except_clause // Used in: plus_except
	: EXCEPT test opt_AS_COMMA
	| EXCEPT
	;
pick_AS_COMMA // Used in: opt_AS_COMMA
	: AS
	| COMMA
	;
opt_AS_COMMA // Used in: except_clause
	: pick_AS_COMMA test
	| %empty
	;
suite // Used in: funcdef, if_stmt, star_ELIF, while_stmt, for_stmt, try_stmt, plus_except, opt_ELSE, opt_FINALLY, with_stmt, classdef
	: simple_stmt
	| NEWLINE INDENT plus_stmt DEDENT
	{
		// $3 is a vector of statements. Grouping them into a suite node
		$$ = new SuiteNode($3);
		pool.add($$);
	}
	;
plus_stmt // Used in: suite, plus_stmt
	: plus_stmt stmt
	{
		// This def wont be the first terminal.
		// So, only push_back statements
		$$ = $1;
		$$->push_back($2);
	}
	| stmt
	// This will be the first terminal when the recursive grammar is expanded.
	// There can be many statements inside the function.
	//  At this point, those statements will already be converted to a corressponding
	// Node*. So using a vector of Node* to represent those statements
	{
		$$ = new std::vector<Node*>();
		$$->reserve(4);
		$$->push_back($1);
	}
	;
testlist_safe // Used in: list_for
	: old_test plus_COMMA_old_test opt_COMMA
	| old_test
	;
plus_COMMA_old_test // Used in: testlist_safe, plus_COMMA_old_test
	: plus_COMMA_old_test COMMA old_test
	| COMMA old_test
	;
old_test // Used in: testlist_safe, plus_COMMA_old_test, old_lambdef, list_if, comp_if
	: or_test
	| old_lambdef
	;
old_lambdef // Used in: old_test
	: LAMBDA varargslist COLON old_test
	| LAMBDA COLON old_test
	;
test // Used in: opt_EQUAL_test, print_stmt, star_COMMA_test, opt_test, plus_COMMA_test, raise_stmt, opt_COMMA_test, opt_test_3, exec_stmt, assert_stmt, if_stmt, star_ELIF, while_stmt, with_item, except_clause, opt_AS_COMMA, opt_IF_ELSE, listmaker, testlist_comp, lambdef, subscript, opt_test_only, sliceop, testlist, dictorsetmaker, star_test_COLON_test, opt_DOUBLESTAR_test, pick_argument, argument, testlist1
	: or_test opt_IF_ELSE
	| lambdef
	{
		$$ = nullptr;
	}
	;
opt_IF_ELSE // Used in: test
	: IF or_test ELSE test
	| %empty
	;
or_test // Used in: old_test, test, opt_IF_ELSE, or_test, comp_for
	: and_test
	| or_test OR and_test
	;
and_test // Used in: or_test, and_test
	: not_test
	| and_test AND not_test
	;
not_test // Used in: and_test, not_test
	: NOT not_test
	{
		$$ = nullptr;
	}
	| comparison
	;
comparison // Used in: not_test, comparison
	: expr
	{
		/* std::cout<<"The single node..."<<std::endl; */
	}
	| comparison comp_op expr
	{
		/* std::cout<<"The comppon node..."<<std::endl; */
		/* comparions and expr are node*s  */
		if ($2 == EQEQUAL) {
			$$ = new EqEqComparisonNode($1, $3);
			pool.add($$);
		} else if ($2 == NOTEQUAL) {
			$$ = new NotEqComparisonNode($1, $3);
			pool.add($$);
		} else if ($2 == GREATER) {
			$$ = new GreaterComparisonNode($1, $3);
			pool.add($$);
		} else if ($2 == GREATEREQUAL) {
			$$ = new GreaterEqComparisonNode($1, $3);
			pool.add($$);
		} else if ($2 == LESS) {
			$$ = new LessComparisonNode($1, $3);
			pool.add($$);
		} else if ($2 == LESSEQUAL) {
			$$ = new LessEqComparisonNode($1, $3);
			pool.add($$);
		} else {
			$$ = $1;
		}
	}
	;
comp_op // Used in: comparison
	: LESS
	{
		$$ = LESS;
	}
	| GREATER
	{
		$$ = GREATER;
	}
	| EQEQUAL
	{
		$$ = EQEQUAL;
	}
	| GREATEREQUAL
	{
		$$ = GREATEREQUAL;
	}
	| LESSEQUAL
	{
		$$ = LESSEQUAL;
	}
	| GRLT
	{
		$$ = GRLT;
	}
	| NOTEQUAL
	{
		$$ = NOTEQUAL;
	}
	| IN
	{
		$$ = IN;
	}
	| NOT IN
	{
		$$ = -1;
	}
	| IS
	{
		$$ = IS;
	}
	| IS NOT
	{
		$$ = -1;
	}
	;
expr // Used in: exec_stmt, with_item, comparison, expr, exprlist, star_COMMA_expr
	: xor_expr
	| expr BAR xor_expr
	;
xor_expr // Used in: expr, xor_expr
	: and_expr
	| xor_expr CIRCUMFLEX and_expr
	;
and_expr // Used in: xor_expr, and_expr
	: shift_expr
	| and_expr AMPERSAND shift_expr
	;
shift_expr // Used in: and_expr, shift_expr
	: arith_expr
	| shift_expr pick_LEFTSHIFT_RIGHTSHIFT arith_expr
	;
pick_LEFTSHIFT_RIGHTSHIFT // Used in: shift_expr
	: LEFTSHIFT
	| RIGHTSHIFT
	;
arith_expr // Used in: shift_expr, arith_expr
	: term
	| arith_expr pick_PLUS_MINUS term
	{
		// Here goes add and sub
		if ($2 == PLUS) {
			/* std::cout << "Yeah it is a PLUS " << std::endl; */
			$$ = new AddBinaryNode($1, $3);
		} else if ($2 == MINUS) {
			/* std::cout << "Yeah it is a MINUS " << std::endl; */
			$$ = new SubBinaryNode($1, $3);
		}
		pool.add($$);
	}
	;
pick_PLUS_MINUS // Used in: arith_expr
	: PLUS
	{
		$$ = PLUS;
	}
	| MINUS
	{
	{
		$$ = MINUS;
	}
	}
	;
term // Used in: arith_expr, term
	: factor
	| term pick_multop factor
	{
		if ($2 == STAR) {
			$$ = new MulBinaryNode($1, $3);
		}
		if ($2 == SLASH) {
			$$ = new DivBinaryNode($1, $3);
		}
		if ($2 == DOUBLESLASH) {
			$$ = new FloorDivBinaryNode($1, $3);
		}
		if ($2 == PERCENT) {
			$$ = new ModBinaryNode($1, $3);
		}
		pool.add($$);
	}
	;
pick_multop // Used in: term
	: STAR
	{
		$$ = STAR;
	}
	| SLASH
	{
		$$ = SLASH;
	}
	| PERCENT
	{
		$$ = PERCENT;
	}
	| DOUBLESLASH
	{
		$$ = DOUBLESLASH;
	}
	;
factor // Used in: term, factor, power
	: pick_unop factor
	{
		$$ = new MinusUnaryNode($2);
		pool.add($$);
	}
	| power
	;
pick_unop // Used in: factor
	: PLUS
	| MINUS
	| TILDE
	;
power // Used in: factor
	: atom star_trailer DOUBLESTAR factor
	{
		$$ = new PowerBinaryNode($1, $4);
		pool.add($$);
	}
	| atom star_trailer
	{
		// This is where the index and the type from which it is indexed meet
		// atom is a node*
		// We now have to index the node* and send the result up...
		/*std::cout<<"Evaluating star_trailer"<<isIndexOn<<std::endl;*/
		if (isIndexOn) {
			/*std::cout<<"========= With Index ================="<<std::endl;*/
			// Modify $1 acc to the index and then propogate it up
			if (hasColon) {
				/*std::cout<<"using complex indexer..."<<std::endl;*/
				/* $$ = new IndexerNode($1, index_range.start, index_range.end, 0, true, shouldUseStrLen); */
				/**
				IndexeNode(Node*, start, end, step, hasColon, shouldUseStrLen, isStartIndexEmpty);
				TODO: Probably too many arguments here. Wrap them up in a data structure.
				**/
				$$ = new IndexerNode($1, index_range.start, index_range.end,
					index_range.step, true, shouldUseStrLen, startIndexEmpty);
			} else {
				/*std::cout<<"using simple indexer..."<<std::endl;*/
				$$ = new IndexerNode($1, index_range.start, 0, 1, false,
					false, startIndexEmpty);
			}
			pool.add($$);
			// Reset states
			isIndexOn = false;
			hasColon = false;
			shouldUseStrLen = false;
			startIndexEmpty = false;
		} else {
			/*std::cout<<"******************* Without Index *******************"<<std::endl;*/
			// No indexing ...
			if (isFunctionCallOn) {
				std::cout<<"At the time of function call... the status of args is... "<< std::endl;
				if ($2 == nullptr) {
					std::cout<<"Empty actaul ..."<<std::endl;
				} else {
					std::cout<<"Actual  actaul ..."<<std::endl;
				}
				const std::string fnName = static_cast<IdentNode*>($1)->getIdent();
				/* std::cout<<"Function Call Flow ================ "<< fnName <<std::endl; */
				$$ = new FunctionCallNode(fnName, $2); // $2 will be nullptr or vector of actual args
				pool.add($$);
				// Reset states
				isFunctionCallOn = false;
			} else {
				$$ = $1;
			}
		}
	}
	;
star_trailer // Used in: power, star_trailer
	: star_trailer trailer
	{
		$$ = $2;
	}
	| %empty
	{
		$$ = nullptr;
	}
	;
atom // Used in: power
	: LPAR opt_yield_test RPAR
	{
		$$ = $2;
	}
	| LSQB opt_listmaker RSQB
	{
		$$ = nullptr;
	}
	| LBRACE opt_dictorsetmaker RBRACE
	{
		$$ = nullptr;
	}
	| BACKQUOTE testlist1 BACKQUOTE
	{
		$$ = nullptr;
	}
	| NAME
	{
		std::cout<<"Well this does not seem to affect the new ... "<< yylval.id <<std::endl;
		$$ = new IdentNode(yylval.id);
		pool.add($$);
		delete[] yylval.id;
	}
	| INT_NUMBER
	{
		$$ = new IntLiteral(yylval.intVal);
		pool.add($$);
	}
	| FLOAT_NUMBER
	{
		$$ = new FloatLiteral(yylval.floatVal);
		pool.add($$);
	}
	| plus_STRING
	{
		std::string strLit = yylval.str;
		strLit = strLit.substr(1, strLit.size() - 2); // remove quotes
		$$ = new StringLiteral(strLit);
		delete[] yylval.str;
		pool.add($$);
	}
	;
pick_yield_expr_testlist_comp // Used in: opt_yield_test
	: yield_expr
	{
		$$ = nullptr;
	}
	| testlist_comp
	;
opt_yield_test // Used in: atom
	: pick_yield_expr_testlist_comp
	{
		$$ = $1;
	}
	| %empty
	{
		$$ = nullptr;
	}
	;
opt_listmaker // Used in: atom
	: listmaker
	| %empty
	;
opt_dictorsetmaker // Used in: atom
	: dictorsetmaker
	| %empty
	;
plus_STRING // Used in: atom, plus_STRING
	: plus_STRING STRING
	| STRING
	;
listmaker // Used in: opt_listmaker
	: test list_for
	| test star_COMMA_test opt_COMMA
	;
testlist_comp // Used in: pick_yield_expr_testlist_comp
	: test comp_for
	| test star_COMMA_test opt_COMMA
	;
lambdef // Used in: test
	: LAMBDA varargslist COLON test
	| LAMBDA COLON test
	;
trailer // Used in: star_trailer
	: LPAR opt_arglist RPAR
	{
		/* $2 is a vector of actual parameters  */
		/* $$ = new ActualParametersNode($2); */
		/* pool.add($$); */
		$$ = $2;
		std::cout<<"The actual params...."<<std::endl;
		/* std::cout<<$2->size()<<std::endl; */
		isFunctionCallOn = true;
	}
	| LSQB subscriptlist RSQB
	{
		$$ = nullptr;
	}
	| DOT NAME
	{
		$$ = nullptr;
	}
	;
subscriptlist // Used in: trailer
	: subscript star_COMMA_subscript COMMA
	| subscript star_COMMA_subscript
	;
star_COMMA_subscript // Used in: subscriptlist, star_COMMA_subscript
	: star_COMMA_subscript COMMA subscript
	| %empty
	;
subscript // Used in: subscriptlist, star_COMMA_subscript
	: DOT DOT DOT
	| test
	{
		// This handles a simple index : a[1]
		// test, if used properly, has to be a IntLiteral*
		// It can be any Node* though
		// FIrst, state changes
		/*std::cout<<"The simple indexer...."<<std::endl;*/
		isIndexOn = true;
		hasColon = false;
		index_range.start = static_cast<const IntLiteral*>($1->eval())->getIntValue();
	}
	| opt_test_only COLON opt_test_only opt_sliceop
	{
		/*std::cout<<"=========================================================="<<std::endl;*/
		/*std::cout<<"The complex indexer...."<<std::endl;*/
		// This handles a complex index a[0:0:0]
		// $1 is the start index - can be nullptr or a node*. If nullptr, consider 0
		// $3 is the end index - can be nullptr or a node*. If nullptr, consider strlen
		// Since strlen cannot be obatined here, set a state useStrLen
		// Update : Getting the step to work
		// $4 is an optional third int argument that can be given to the slice operation
		// $4 can be nullptr or a node*. If nullptr, consider 1. It cannot be 0.
		/* std::cout<<"State of $4 is : "<<($4 == nullptr)<<std::endl; */
		isIndexOn = true;
		hasColon = true;
		// Start Index
		if ($1 == nullptr) {
			index_range.start = 0;
			startIndexEmpty = true;
		} else {
			startIndexEmpty = false;
			index_range.start = static_cast<const IntLiteral*>($1->eval())->getIntValue();
		}
		// End Index
		if ($3 == nullptr) {
			index_range.end = 0;
			shouldUseStrLen = true;
		} else {
			shouldUseStrLen = false;
			index_range.end = static_cast<const IntLiteral*>($3->eval())->getIntValue();
		}
		// Step Index
		if ($4 == nullptr) {
			index_range.step =  1;
		} else {
			index_range.step = static_cast<const IntLiteral*>($4->eval())->getIntValue();
		}
		/* std::cout<<"Start : "<<	index_range.start << std::endl;
		std::cout<<"End : "<<	index_range.end << std::endl;
		std::cout<<"Should Use End : "<<	shouldUseStrLen << std::endl;
		std::cout<<"Start Index Empty : "<<	startIndexEmpty << std::endl;
		std::cout<<"Step : "<<	index_range.step << std::endl;
		std::cout<<"=========================================================="<<std::endl; */
	}
	;
opt_test_only // Used in: subscript
	: test
	{
		$$ = $1;
	}
	| %empty
	{
		$$ = nullptr;
	}
	;
opt_sliceop // Used in: subscript
	: sliceop
	{
		$$ = $1;
	}
	| %empty
	{
		$$ = nullptr;
	}
	;
sliceop // Used in: opt_sliceop
	: COLON test
	{
		/* std::cout<<"It finally comes here ... "<<std::endl; */
		$$ = $2;
	}
	| COLON
	{
		/* std::cout<<"It finally comes here with a nullptr... "<<std::endl; */
		$$ = nullptr;
	}
	;
exprlist // Used in: del_stmt, for_stmt, list_for, comp_for
	: expr star_COMMA_expr COMMA
	| expr star_COMMA_expr
	;
star_COMMA_expr // Used in: exprlist, star_COMMA_expr
	: star_COMMA_expr COMMA expr
	| %empty
	;
testlist // Used in: expr_stmt, pick_yield_expr_testlist, return_stmt, for_stmt, opt_testlist, yield_expr
	: test star_COMMA_test COMMA
	| test star_COMMA_test
	;
dictorsetmaker // Used in: opt_dictorsetmaker
	: test COLON test pick_for_test_test
	| test pick_for_test
	;
star_test_COLON_test // Used in: star_test_COLON_test, pick_for_test_test
	: star_test_COLON_test COMMA test COLON test
	| %empty
	;
pick_for_test_test // Used in: dictorsetmaker
	: comp_for
	| star_test_COLON_test opt_COMMA
	;
pick_for_test // Used in: dictorsetmaker
	: comp_for
	| star_COMMA_test opt_COMMA
	;
classdef // Used in: decorated, compound_stmt
	: CLASS NAME LPAR opt_testlist RPAR COLON suite
	| CLASS NAME COLON suite
	;
opt_testlist // Used in: classdef
	: testlist
	| %empty
	;
arglist // Used in: opt_arglist
	: star_argument_COMMA pick_argument
	{
		std::cout<<"THats the one or last"<<std::endl;
		$$->push_back($2);
	}
	;
star_argument_COMMA // Used in: arglist, star_argument_COMMA
	: star_argument_COMMA argument COMMA
	{
		$$ = $1;
		$$->push_back($2);
		std::cout<<"Thats the second here...."<<std::endl;
	}
	| %empty
	{
		std::cout<<"Thats the emoty here...."<<std::endl;
		$$ = new std::vector<Node*>();
		$$->reserve(4);
	}
	;
star_COMMA_argument // Used in: star_COMMA_argument, pick_argument
	: star_COMMA_argument COMMA argument
	| %empty
	;
opt_DOUBLESTAR_test // Used in: pick_argument
	: COMMA DOUBLESTAR test
	| %empty
	;
pick_argument // Used in: arglist
	: argument opt_COMMA
	{
		$$ = $1;
	}
	| STAR test star_COMMA_argument opt_DOUBLESTAR_test
	{
		$$ = nullptr;
	}
	| DOUBLESTAR test
	{
		$$ = nullptr;
	}
	;
argument // Used in: star_argument_COMMA, star_COMMA_argument, pick_argument
	: test opt_comp_for
	| test EQUAL test
	{
		/* std::cout<<"So you are here ?.."<<std::endl; */
	}
	;
opt_comp_for // Used in: argument
	: comp_for
	| %empty
	;
list_iter // Used in: list_for, list_if
	: list_for
	| list_if
	;
list_for // Used in: listmaker, list_iter
	: FOR exprlist IN testlist_safe list_iter
	| FOR exprlist IN testlist_safe
	;
list_if // Used in: list_iter
	: IF old_test list_iter
	| IF old_test
	;
comp_iter // Used in: comp_for, comp_if
	: comp_for
	| comp_if
	;
comp_for // Used in: testlist_comp, pick_for_test_test, pick_for_test, opt_comp_for, comp_iter
	: FOR exprlist IN or_test comp_iter
	| FOR exprlist IN or_test
	;
comp_if // Used in: comp_iter
	: IF old_test comp_iter
	| IF old_test
	;
testlist1 // Used in: atom, testlist1
	: test
	| testlist1 COMMA test
	;
yield_expr // Used in: pick_yield_expr_testlist, yield_stmt, pick_yield_expr_testlist_comp
	: YIELD testlist
	| YIELD
	;
star_DOT // Used in: pick_dotted_name, star_DOT
	: star_DOT DOT
	| %empty
	;

%%

#include <stdio.h>
void yyerror (const char *s)
{
    if(yylloc.first_line > 0)	{
        fprintf (stderr, "%d.%d-%d.%d:", yylloc.first_line, yylloc.first_column,
	                                     yylloc.last_line,  yylloc.last_column);
    }
    fprintf(stderr, " %s with [%s]\n", s, yytext);
}
